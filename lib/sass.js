"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const s = require("node-sass");
const dopees_chain_1 = require("dopees-chain");
const fs = require("fs");
const fspath = require("path");
const fsp = fs.promises;
// const fileStat = (path: string): Promise<fs.Stats> => new Promise((resolve, reject) => fs.stat(path, (err, stats) => err ? reject(err) : resolve(stats)));
const fileExists = (path) => fsp.access(path).then(() => true, () => false);
const sassRender = (options) => new Promise((resolve, reject) => s.render(options, (err, result) => {
    if (err) {
        reject(err);
    }
    else {
        resolve(result);
    }
}));
const resolveDependency = async (rootPath, path, includePaths) => {
    let folder;
    let fname;
    if (path.includes(fspath.sep)) {
        folder = fspath.dirname(path);
        fname = fspath.basename(path);
    }
    else {
        folder = '';
        fname = path;
    }
    if (!fname.endsWith('.scss')) {
        fname = fname + '.scss';
    }
    for (const basePath of includePaths) {
        let candidate = fspath.normalize(fspath.join(basePath, folder, fname));
        if (await fileExists(candidate)) {
            return candidate;
        }
        if (!fname.startsWith('_')) {
            candidate = fspath.normalize(fspath.join(basePath, folder, '_' + fname));
            if (await fileExists(candidate)) {
                return candidate;
            }
        }
    }
    throw new Error(`could not resolve ${path} while processing ${rootPath}, search paths: ${includePaths}`);
};
const getMatches = (regex, input) => {
    const result = [];
    for (let m = regex.exec(input); m; m = regex.exec(input)) {
        result.push(m);
    }
    return result;
};
class SassMapperState {
    constructor(options) {
        this.sourceResolver = dopees_chain_1.ReversePathResolver.from(options);
        this.innerStateKey = 'sass.innerState';
        const extension = `.${options.targetExt || 'css'}`;
        this.selector = (path, context) => {
            const absoluteTargetRoot = fspath.normalize(fspath.join(context.basePath, options.targetRoot));
            return path.endsWith(extension) && dopees_chain_1.PathResolver.match(path, absoluteTargetRoot, options.subfolders);
        };
        this.outputStyle = options.outputStyle;
        this.precision = options.precision;
    }
}
exports.SassMapperState = SassMapperState;
class SassMapper extends dopees_chain_1.derived.FileMapper {
    constructor() {
        super(...arguments);
        this.name = 'sass';
    }
    async generate(state, task, innerState, _) {
        const options = {
            outputStyle: state.outputStyle || 'compressed',
            precision: state.precision,
            file: innerState.sourcePath,
            data: innerState.sourceCode,
            outFile: task.name.path,
            sourceMap: true
        };
        const sassResult = await sassRender(options);
        return sassResult.css;
    }
    async readSource(_, task, context) {
        const code = await context.getContents(task, 'utf-8');
        return {
            sourceCode: code,
            sourcePath: task.name.path
        };
    }
    init(options) { return new SassMapperState(options); }
}
exports.SassMapper = SassMapper;
class SassDependencyResolver extends dopees_chain_1.derived.FileDependencyResolver {
    constructor() {
        super(...arguments);
        this.name = 'sass:deps';
    }
    async readSource(_, task, context) {
        const code = await context.getContents(task, 'utf-8');
        return {
            sourceCode: code,
            sourcePath: task.name.path
        };
    }
    async readDependencies(_, task, innerState, context) {
        const folder = fspath.dirname(innerState.sourcePath);
        return await Promise.all(getMatches(/^@import '(.*)';?$/mg, innerState.sourceCode)
            .map(m => m[1])
            .map(relative => resolveDependency(folder, relative, [folder]))); // FIXME: includePaths
    }
    init(options) {
        const extension = `.${options.sourceExt || 'scss'}`;
        return {
            selector: (path) => path.endsWith(extension),
            dependenciesKey: 'sass.dependencies',
            innerStateKey: 'sass.innerState'
        };
    }
}
exports.SassDependencyResolver = SassDependencyResolver;
function sass(options) {
    if (!options) {
        throw new Error('targetRoot must be specified');
    }
    // FIXME: propagate
    // const includePaths = opts.includePaths || [];
    const sassExecutor = new SassMapper().createExecutor(options);
    const sassDepsExecutor = new SassDependencyResolver().createExecutor(options);
    return dopees_chain_1.Executors.combine(sassExecutor, sassDepsExecutor);
}
exports.sass = sass;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2Fzcy5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uL3NyYy9zYXNzLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7O0FBQUEsK0JBQStCO0FBQy9CLCtDQUFpSztBQUNqSyx5QkFBeUI7QUFDekIsK0JBQStCO0FBRS9CLE1BQU0sR0FBRyxHQUFHLEVBQUUsQ0FBQyxRQUFRLENBQUM7QUFFeEIsNkpBQTZKO0FBRTdKLE1BQU0sVUFBVSxHQUFHLENBQUMsSUFBWSxFQUFvQixFQUFFLENBQUMsR0FBRyxDQUFDLE1BQU0sQ0FBQyxJQUFJLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxFQUFFLENBQUMsSUFBSSxFQUFFLEdBQUcsRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBRXRHLE1BQU0sVUFBVSxHQUFHLENBQUMsT0FBa0IsRUFBcUIsRUFBRSxDQUFDLElBQUksT0FBTyxDQUFDLENBQUMsT0FBTyxFQUFFLE1BQU0sRUFBRSxFQUFFLENBQUMsQ0FBQyxDQUFDLE1BQU0sQ0FBQyxPQUFPLEVBQUUsQ0FBQyxHQUFHLEVBQUUsTUFBTSxFQUFFLEVBQUU7SUFDL0gsSUFBSSxHQUFHLEVBQUU7UUFDUCxNQUFNLENBQUMsR0FBRyxDQUFDLENBQUM7S0FDYjtTQUFNO1FBQ0wsT0FBTyxDQUFDLE1BQU0sQ0FBQyxDQUFDO0tBQ2pCO0FBQ0gsQ0FBQyxDQUFDLENBQUMsQ0FBQTtBQUVILE1BQU0saUJBQWlCLEdBQUcsS0FBSyxFQUFFLFFBQWUsRUFBRSxJQUFZLEVBQUUsWUFBc0IsRUFBRSxFQUFFO0lBQ3hGLElBQUksTUFBYyxDQUFDO0lBQ25CLElBQUksS0FBYSxDQUFDO0lBQ2xCLElBQUksSUFBSSxDQUFDLFFBQVEsQ0FBQyxNQUFNLENBQUMsR0FBRyxDQUFDLEVBQUU7UUFDN0IsTUFBTSxHQUFHLE1BQU0sQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLENBQUM7UUFDOUIsS0FBSyxHQUFHLE1BQU0sQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLENBQUM7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QUUsZ0JBQWdCLENBQUMsQ0FBQztBQUMzRCxDQUFDO0FBVEQsb0JBU0MiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBzIGZyb20gJ25vZGUtc2Fzcyc7XG5pbXBvcnQgeyBFeGVjdXRvciwgVGFzaywgQ29udGV4dCwgRmlsZU5hbWUsIEhlbHBlcnMgYXMgaCwgUmV2ZXJzZVBhdGhSZXNvbHZlckNvbmZpZywgUmV2ZXJzZVBhdGhSZXNvbHZlciwgZGVyaXZlZCwgUGF0aFJlc29sdmVyLCBFeGVjdXRvcnMgfSBmcm9tICdkb3BlZXMtY2hhaW4nO1xuaW1wb3J0ICogYXMgZnMgZnJvbSAnZnMnO1xuaW1wb3J0ICogYXMgZnNwYXRoIGZyb20gJ3BhdGgnO1xuXG5jb25zdCBmc3AgPSBmcy5wcm9taXNlcztcblxuLy8gY29uc3QgZmlsZVN0YXQgPSAocGF0aDogc3RyaW5nKTogUHJvbWlzZTxmcy5TdGF0cz4gPT4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gZnMuc3RhdChwYXRoLCAoZXJyLCBzdGF0cykgPT4gZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHN0YXRzKSkpO1xuXG5jb25zdCBmaWxlRXhpc3RzID0gKHBhdGg6IHN0cmluZyk6IFByb21pc2U8Ym9vbGVhbj4gPT4gZnNwLmFjY2VzcyhwYXRoKS50aGVuKCgpID0+IHRydWUsICgpID0+IGZhbHNlKTtcblxuY29uc3Qgc2Fzc1JlbmRlciA9IChvcHRpb25zOiBzLk9wdGlvbnMpOiBQcm9taXNlPHMuUmVzdWx0PiA9PiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiBzLnJlbmRlcihvcHRpb25zLCAoZXJyLCByZXN1bHQpID0+IHtcbiAgaWYgKGVycikge1xuICAgIHJlamVjdChlcnIpO1xuICB9IGVsc2Uge1xuICAgIHJlc29sdmUocmVzdWx0KTtcbiAgfVxufSkpXG5cbmNvbnN0IHJlc29sdmVEZXBlbmRlbmN5ID0gYXN5bmMgKHJvb3RQYXRoOnN0cmluZywgcGF0aDogc3RyaW5nLCBpbmNsdWRlUGF0aHM6IHN0cmluZ1tdKSA9PiB7XG4gIGxldCBmb2xkZXI6IHN0cmluZztcbiAgbGV0IGZuYW1lOiBzdHJpbmc7XG4gIGlmIChwYXRoLmluY2x1ZGVzKGZzcGF0aC5zZXApKSB7XG4gICAgZm9sZGVyID0gZnNwYXRoLmRpcm5hbWUocGF0aCk7XG4gICAgZm5hbWUgPSBmc3BhdGguYmFzZW5hbWUocGF0aCk7XG4gIH0gZWxzZSB7XG4gICAgZm9sZGVyID0gJyc7XG4gICAgZm5hbWUgPSBwYXRoO1xuICB9XG4gIGlmICghZm5hbWUuZW5kc1dpdGgoJy5zY3NzJykpIHtcbiAgICBmbmFtZSA9IGZuYW1lICsgJy5zY3NzJztcbiAgfVxuICBmb3IgKGNvbnN0IGJhc2VQYXRoIG9mIGluY2x1ZGVQYXRocykge1xuICAgIGxldCBjYW5kaWRhdGUgPSBmc3BhdGgubm9ybWFsaXplKGZzcGF0aC5qb2luKGJhc2VQYXRoLCBmb2xkZXIsIGZuYW1lKSk7XG4gICAgaWYgKGF3YWl0IGZpbGVFeGlzdHMoY2FuZGlkYXRlKSkge1xuICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICB9XG4gICAgaWYgKCFmbmFtZS5zdGFydHNXaXRoKCdfJykpIHtcbiAgICAgIGNhbmRpZGF0ZSA9IGZzcGF0aC5ub3JtYWxpemUoZnNwYXRoLmpvaW4oYmFzZVBhdGgsIGZvbGRlciwgJ18nICsgZm5hbWUpKTtcbiAgICAgIGlmIChhd2FpdCBmaWxlRXhpc3RzKGNhbmRpZGF0ZSkpIHtcbiAgICAgICAgcmV0dXJuIGNhbmRpZGF0ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKGBjb3VsZCBub3QgcmVzb2x2ZSAke3BhdGh9IHdoaWxlIHByb2Nlc3NpbmcgJHtyb290UGF0aH0sIHNlYXJjaCBwYXRoczogJHtpbmNsdWRlUGF0aHN9YCk7XG59XG5cbmNvbnN0IGdldE1hdGNoZXMgPSAocmVnZXg6IFJlZ0V4cCwgaW5wdXQ6IHN0cmluZykgPT4ge1xuICBjb25zdCByZXN1bHQgPSBbXTtcbiAgZm9yIChsZXQgbSA9IHJlZ2V4LmV4ZWMoaW5wdXQpOyBtOyBtID0gcmVnZXguZXhlYyhpbnB1dCkpIHtcbiAgICByZXN1bHQucHVzaChtKTtcbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG5pbnRlcmZhY2UgRGVwZW5kZW5jaWVzIHtcbiAgcmVhZG9ubHkgbXRpbWU6IERhdGU7XG4gIHJlYWRvbmx5IGRlcHM6IHN0cmluZ1tdO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIE9wdGlvbnMgZXh0ZW5kcyBSZXZlcnNlUGF0aFJlc29sdmVyQ29uZmlnIHtcbiAgdGFyZ2V0Um9vdDogc3RyaW5nO1xuICBzdWJmb2xkZXJzPzogYm9vbGVhbjtcbiAgLy9zb3VyY2VSZXNvbHZlcj86IChwYXRoOiBzdHJpbmcsIGJhc2VQYXRoPzogc3RyaW5nKSA9PiBzdHJpbmc7XG4gIGluY2x1ZGVQYXRocz86IHN0cmluZ1tdO1xuICBvdXRwdXRTdHlsZT86IFwiY29tcGFjdFwiIHwgXCJjb21wcmVzc2VkXCIgfCBcImV4cGFuZGVkXCIgfCBcIm5lc3RlZFwiO1xuICBwcmVjaXNpb24/OiBudW1iZXI7XG4gIHBlcnNpc3RzPzogYm9vbGVhblxufVxuXG5leHBvcnQgY2xhc3MgU2Fzc01hcHBlclN0YXRlIGltcGxlbWVudHMgZGVyaXZlZC5GaWxlTWFwcGVyU3RhdGUge1xuICBzb3VyY2VSZXNvbHZlcjogUGF0aFJlc29sdmVyO1xuICBpbm5lclN0YXRlS2V5OiBzdHJpbmc7XG4gIHNlbGVjdG9yOiAocGF0aDogc3RyaW5nLCBjb250ZXh0OiBDb250ZXh0KSA9PiBib29sZWFuO1xuICBvdXRwdXRTdHlsZT86IFwiY29tcGFjdFwiIHwgXCJjb21wcmVzc2VkXCIgfCBcImV4cGFuZGVkXCIgfCBcIm5lc3RlZFwiO1xuICBwcmVjaXNpb24/OiBudW1iZXI7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnM6IE9wdGlvbnMpIHtcbiAgICB0aGlzLnNvdXJjZVJlc29sdmVyID0gUmV2ZXJzZVBhdGhSZXNvbHZlci5mcm9tKG9wdGlvbnMpO1xuICAgIHRoaXMuaW5uZXJTdGF0ZUtleSA9ICdzYXNzLmlubmVyU3RhdGUnO1xuICAgIGNvbnN0IGV4dGVuc2lvbiA9IGAuJHtvcHRpb25zLnRhcmdldEV4dCB8fCAnY3NzJ31gO1xuICAgIHRoaXMuc2VsZWN0b3IgPSAocGF0aDogc3RyaW5nLCBjb250ZXh0OiBDb250ZXh0KSA9PiB7XG4gICAgICBjb25zdCBhYnNvbHV0ZVRhcmdldFJvb3QgPSBmc3BhdGgubm9ybWFsaXplKGZzcGF0aC5qb2luKGNvbnRleHQuYmFzZVBhdGgsIG9wdGlvbnMudGFyZ2V0Um9vdCkpO1xuICAgICAgcmV0dXJuIHBhdGguZW5kc1dpdGgoZXh0ZW5zaW9uKSAmJiBQYXRoUmVzb2x2ZXIubWF0Y2gocGF0aCwgYWJzb2x1dGVUYXJnZXRSb290LCBvcHRpb25zLnN1YmZvbGRlcnMpO1xuICAgIH07XG4gICAgdGhpcy5vdXRwdXRTdHlsZSA9IG9wdGlvbnMub3V0cHV0U3R5bGU7XG4gICAgdGhpcy5wcmVjaXNpb24gPSBvcHRpb25zLnByZWNpc2lvblxuICB9XG59XG5cbmludGVyZmFjZSBTYXNzSW5uZXJTdGF0ZSB7XG4gIHJlYWRvbmx5IHNvdXJjZUNvZGU6IHN0cmluZztcbiAgcmVhZG9ubHkgc291cmNlUGF0aDogc3RyaW5nO1xufVxuXG5leHBvcnQgY2xhc3MgU2Fzc01hcHBlciBleHRlbmRzIGRlcml2ZWQuRmlsZU1hcHBlcjxPcHRpb25zLCBTYXNzSW5uZXJTdGF0ZSwgU2Fzc01hcHBlclN0YXRlPiAge1xuICBuYW1lID0gJ3Nhc3MnO1xuICBwcm90ZWN0ZWQgYXN5bmMgZ2VuZXJhdGUoc3RhdGU6IFNhc3NNYXBwZXJTdGF0ZSwgdGFzazogVGFzaywgaW5uZXJTdGF0ZTogU2Fzc0lubmVyU3RhdGUsIF86IENvbnRleHQpIHtcbiAgICBjb25zdCBvcHRpb25zIDogcy5PcHRpb25zID0ge1xuICAgICAgb3V0cHV0U3R5bGU6IHN0YXRlLm91dHB1dFN0eWxlIHx8ICdjb21wcmVzc2VkJyxcbiAgICAgIHByZWNpc2lvbjogc3RhdGUucHJlY2lzaW9uLFxuICAgICAgZmlsZTogaW5uZXJTdGF0ZS5zb3VyY2VQYXRoLFxuICAgICAgZGF0YTogaW5uZXJTdGF0ZS5zb3VyY2VDb2RlLFxuICAgICAgb3V0RmlsZTogKDxGaWxlTmFtZT50YXNrLm5hbWUpLnBhdGgsXG4gICAgICBzb3VyY2VNYXA6IHRydWVcbiAgICB9O1xuICAgIGNvbnN0IHNhc3NSZXN1bHQgPSBhd2FpdCBzYXNzUmVuZGVyKG9wdGlvbnMpO1xuICAgIHJldHVybiBzYXNzUmVzdWx0LmNzcztcbiAgfVxuICBwcm90ZWN0ZWQgYXN5bmMgcmVhZFNvdXJjZShfOiBTYXNzTWFwcGVyU3RhdGUsIHRhc2s6IFRhc2ssIGNvbnRleHQ6IENvbnRleHQpIHtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgY29udGV4dC5nZXRDb250ZW50cyh0YXNrLCAndXRmLTgnKTtcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlQ29kZTogY29kZSxcbiAgICAgIHNvdXJjZVBhdGg6ICg8RmlsZU5hbWU+dGFzay5uYW1lKS5wYXRoXG4gICAgfTtcbiAgfVxuICBwcm90ZWN0ZWQgaW5pdChvcHRpb25zOiBPcHRpb25zKTogU2Fzc01hcHBlclN0YXRlIHsgcmV0dXJuIG5ldyBTYXNzTWFwcGVyU3RhdGUob3B0aW9ucyk7IH1cbn1cblxuZXhwb3J0IGNsYXNzIFNhc3NEZXBlbmRlbmN5UmVzb2x2ZXIgZXh0ZW5kcyBkZXJpdmVkLkZpbGVEZXBlbmRlbmN5UmVzb2x2ZXI8eyBzb3VyY2VFeHQ/OiBzdHJpbmcgfSwgU2Fzc0lubmVyU3RhdGUsIGRlcml2ZWQuRmlsZURlcGVuZGVuY3lSZXNvbHZlclN0YXRlICYgeyBpbm5lclN0YXRlS2V5OiBzdHJpbmcsIGRlcGVuZGVuY2llc0tleTogc3RyaW5nIH0+IHtcbiAgbmFtZSA9ICdzYXNzOmRlcHMnO1xuICBwcm90ZWN0ZWQgYXN5bmMgcmVhZFNvdXJjZShfOiBkZXJpdmVkLkZpbGVEZXBlbmRlbmN5UmVzb2x2ZXJTdGF0ZSAmIHsgaW5uZXJTdGF0ZUtleTogc3RyaW5nOyBkZXBlbmRlbmNpZXNLZXk6IHN0cmluZzsgfSwgdGFzazogVGFzaywgY29udGV4dDogQ29udGV4dCk6IFByb21pc2U8U2Fzc0lubmVyU3RhdGU+IHtcbiAgICBjb25zdCBjb2RlID0gYXdhaXQgY29udGV4dC5nZXRDb250ZW50cyh0YXNrLCAndXRmLTgnKTtcbiAgICByZXR1cm4ge1xuICAgICAgc291cmNlQ29kZTogY29kZSxcbiAgICAgIHNvdXJjZVBhdGg6ICg8RmlsZU5hbWU+dGFzay5uYW1lKS5wYXRoXG4gICAgfTtcbiAgfVxuICBwcm90ZWN0ZWQgYXN5bmMgcmVhZERlcGVuZGVuY2llcyhfOiBkZXJpdmVkLkZpbGVEZXBlbmRlbmN5UmVzb2x2ZXJTdGF0ZSAmIHsgaW5uZXJTdGF0ZUtleTogc3RyaW5nOyBkZXBlbmRlbmNpZXNLZXk6IHN0cmluZzsgfSwgdGFzazogVGFzaywgaW5uZXJTdGF0ZTogU2Fzc0lubmVyU3RhdGUsIGNvbnRleHQ6IENvbnRleHQpOiBQcm9taXNlPHN0cmluZ1tdPiB7XG4gICAgY29uc3QgZm9sZGVyID0gZnNwYXRoLmRpcm5hbWUoaW5uZXJTdGF0ZS5zb3VyY2VQYXRoKTtcbiAgICByZXR1cm4gYXdhaXQgUHJvbWlzZS5hbGwoZ2V0TWF0Y2hlcygvXkBpbXBvcnQgJyguKiknOz8kL21nLCBpbm5lclN0YXRlLnNvdXJjZUNvZGUpXG4gICAgICAubWFwKG0gPT4gbVsxXSlcbiAgICAgIC5tYXAocmVsYXRpdmUgPT4gcmVzb2x2ZURlcGVuZGVuY3koZm9sZGVyLCByZWxhdGl2ZSwgWyBmb2xkZXIgXSkpKTsgLy8gRklYTUU6IGluY2x1ZGVQYXRoc1xuICB9XG4gIHByb3RlY3RlZCBpbml0KG9wdGlvbnM6IHsgc291cmNlRXh0Pzogc3RyaW5nIH0pOiBkZXJpdmVkLkZpbGVEZXBlbmRlbmN5UmVzb2x2ZXJTdGF0ZSAmIHsgaW5uZXJTdGF0ZUtleTogc3RyaW5nOyBkZXBlbmRlbmNpZXNLZXk6IHN0cmluZzsgfSB7XG4gICAgY29uc3QgZXh0ZW5zaW9uID0gYC4ke29wdGlvbnMuc291cmNlRXh0IHx8ICdzY3NzJ31gO1xuICAgIHJldHVybiB7XG4gICAgICBzZWxlY3RvcjogKHBhdGg6IHN0cmluZykgPT4gcGF0aC5lbmRzV2l0aChleHRlbnNpb24pLFxuICAgICAgZGVwZW5kZW5jaWVzS2V5OiAnc2Fzcy5kZXBlbmRlbmNpZXMnLFxuICAgICAgaW5uZXJTdGF0ZUtleTogJ3Nhc3MuaW5uZXJTdGF0ZSdcbiAgICB9O1xuICB9XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzYXNzKG9wdGlvbnM/OiBPcHRpb25zKTogRXhlY3V0b3Ige1xuICBpZiAoIW9wdGlvbnMpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3RhcmdldFJvb3QgbXVzdCBiZSBzcGVjaWZpZWQnKTtcbiAgfVxuICAvLyBGSVhNRTogcHJvcGFnYXRlXG4gIC8vIGNvbnN0IGluY2x1ZGVQYXRocyA9IG9wdHMuaW5jbHVkZVBhdGhzIHx8IFtdO1xuICBjb25zdCBzYXNzRXhlY3V0b3IgPSBuZXcgU2Fzc01hcHBlcigpLmNyZWF0ZUV4ZWN1dG9yKG9wdGlvbnMpO1xuICBjb25zdCBzYXNzRGVwc0V4ZWN1dG9yID0gbmV3IFNhc3NEZXBlbmRlbmN5UmVzb2x2ZXIoKS5jcmVhdGVFeGVjdXRvcihvcHRpb25zKTtcbiAgcmV0dXJuIEV4ZWN1dG9ycy5jb21iaW5lKHNhc3NFeGVjdXRvciwgc2Fzc0RlcHNFeGVjdXRvcik7XG59Il19